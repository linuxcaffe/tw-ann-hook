#!/usr/bin/env bash
# annn - Annotation helper for Taskwarrior
# version 0.5.2
#
# Usage:
#   annn <id>                    Open $EDITOR for a new annotation
#   annn <id>.                   List all annotations with index numbers
#   annn <id>.<N>                Edit annotation N in $EDITOR
#   annn <id>.<N> text...        Edit annotation N, pre-populated with text
#   annn -<id>.<N>               Remove annotation N (with confirmation)
#   annn <id> text...            Annotate directly, no editor
#   echo "text" | annn <id>      Annotate from pipe, no editor
#
# Designed for Taskwarrior 2.6.2
# License: MIT

set -euo pipefail

readonly VERSION="0.5.1"
readonly SCRIPT_NAME="$(basename "$0")"
readonly EDITOR="${EDITOR:-vim}"

# Global tmpfile for trap cleanup (avoids "unbound variable" with set -u)
tmpfile=""
trap 'rm -f "$tmpfile"' EXIT

# ============================================================================
# Helpers
# ============================================================================

usage() {
    cat <<EOF
Usage: $SCRIPT_NAME <id>[.<N>] [text...]

  $SCRIPT_NAME <id>                    New annotation (opens \$EDITOR)
  $SCRIPT_NAME <id> text...            New annotation, no editor
  $SCRIPT_NAME <id>.                   List annotations
  $SCRIPT_NAME <id>.<N>                Edit annotation N (opens \$EDITOR)
  $SCRIPT_NAME <id>.<N> text...        Edit annotation N, pre-populated with text
  $SCRIPT_NAME -<id>.<N>               Remove annotation N (requires index)
  echo "text" | $SCRIPT_NAME <id>      Annotate from pipe, no editor

  <id> must be a plain integer or UUID — no filters, tags, or project expressions.

Examples:
  $SCRIPT_NAME 42                      Add new annotation to task 42
  $SCRIPT_NAME 42 Fixed the bug        Inline annotation, no editor
  $SCRIPT_NAME 42.                     List annotations on task 42
  $SCRIPT_NAME 42.1                    Edit first annotation on task 42
  $SCRIPT_NAME 42.1 see ticket #99     Edit annotation 1, pre-populated
  $SCRIPT_NAME -42.1                   Remove first annotation from task 42
  echo "quick note" | $SCRIPT_NAME 42  Pipe a one-liner

Options:
  -h, --help       Show this help
  -v, --version    Show version
EOF
    exit 0
}

die() {
    echo "[annn] ERROR: $*" >&2
    exit 1
}

msg() {
    echo "[annn] $*"
}

# ============================================================================
# Validate that a value is a plain integer (task ID)
# ============================================================================

is_integer() {
    [[ "$1" =~ ^[0-9]+$ ]]
}

# ============================================================================
# Validate that a value is a UUID
# ============================================================================

is_uuid() {
    [[ "$1" =~ ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$ ]]
}

# ============================================================================
# Validate arg1 is a strict ID or ID.N form — no filters, tags, or keywords
# Accepts: 42  42.  42.3  -42.3  <uuid>
# ============================================================================

validate_id_arg() {
    local arg="$1"

    # Remove leading minus for remove-mode check
    local bare="${arg#-}"

    # Combined dot forms: 42.  42.3  -42.3
    if [[ "$bare" =~ ^([0-9]+)(\.([0-9]*))?$ ]]; then
        return 0
    fi

    # UUID (with optional leading minus — unusual but handle gracefully)
    if is_uuid "$bare"; then
        return 0
    fi

    die "Invalid ID: '$arg' — must be a plain integer or UUID (no filters, tags, or project expressions)"
}

# ============================================================================
# Sanitize task description for use in temp filename
# ============================================================================

sanitize_for_filename() {
    echo "$1" | tr '[:upper:]' '[:lower:]' \
              | sed 's/[^a-z0-9]/-/g; s/--*/-/g; s/^-//; s/-$//' \
              | cut -c1-40
}

# ============================================================================
# Make a descriptive temp file for a given task ID
# ============================================================================

make_tmpfile() {
    local id="$1"
    local desc
    desc=$(task _get "$id.description" 2>/dev/null || echo "")
    local slug
    slug=$(sanitize_for_filename "${desc:-task}")
    tmpfile=$(mktemp "/tmp/annn_${id}_${slug}.XXXXXX.md")
}

# ============================================================================
# Get annotation count via DOM
# ============================================================================

get_annotation_count() {
    local id="$1"
    local count=0
    while true; do
        local next=$(( count + 1 ))
        local desc
        desc=$(task _get "$id.annotations.${next}.description" 2>/dev/null) || break
        [[ -z "$desc" ]] && break
        count=$next
    done
    echo "$count"
}

# ============================================================================
# Resolve a strict ID (integer or UUID) to confirmed task ID
# ============================================================================

resolve_id() {
    local raw="$1"
    local id

    # Confirm the task exists
    id=$(task rc.verbose=nothing rc.color=off "$raw" _ids 2>/dev/null | head -1)

    if [[ -z "$id" ]]; then
        die "No task found with ID: $raw"
    fi

    echo "$id"
}

# ============================================================================
# Show task context line with annotation count
# ============================================================================

show_task_context() {
    local id="$1"
    local desc
    desc=$(task _get "$id.description" 2>/dev/null || echo "")
    local count
    count=$(get_annotation_count "$id")

    if [[ "$count" -eq 0 ]]; then
        msg "Task $id: $desc (no annotations)"
    elif [[ "$count" -eq 1 ]]; then
        msg "Task $id: $desc (1 annotation)"
    else
        msg "Task $id: $desc ($count annotations)"
    fi
}

# ============================================================================
# List annotations
# ============================================================================

list_annotations() {
    local id="$1"
    local count
    count=$(get_annotation_count "$id")

    if [[ "$count" -eq 0 ]]; then
        msg "No annotations on task $id"
        return
    fi

    local desc
    desc=$(task _get "$id.description" 2>/dev/null)
    echo "Task $id: $desc"
    echo "---"

    local i=1
    while [[ $i -le $count ]]; do
        local ann_desc ann_entry
        ann_desc=$(task _get "$id.annotations.${i}.description" 2>/dev/null)
        ann_entry=$(task _get "$id.annotations.${i}.entry" 2>/dev/null)

        local date_str="$ann_entry"
        if command -v date &>/dev/null && [[ -n "$ann_entry" ]]; then
            date_str=$(date -d "$ann_entry" "+%Y-%m-%d %H:%M" 2>/dev/null) || date_str="$ann_entry"
        fi

        printf "  .%-3d [%s]\n" "$i" "$date_str"
        echo "$ann_desc" | sed 's/^/       /'
        echo ""
        i=$(( i + 1 ))
    done
}

# ============================================================================
# New annotation — editor, inline text, or pipe
# ============================================================================

new_annotation() {
    local id="$1"
    local inline_text="${2:-}"   # optional pre-supplied text

    local annot

    if [[ ! -t 0 ]]; then
        # Piped input — read stdin directly, skip editor
        annot="$(cat)"
        if [[ -z "$annot" ]]; then
            msg "Empty input, nothing saved."
            return
        fi

    elif [[ -n "$inline_text" ]]; then
        # Inline text supplied on command line — no editor
        annot="$inline_text"

    else
        # Interactive — show context and open editor
        show_task_context "$id"
        make_tmpfile "$id"
        $EDITOR "$tmpfile"

        if [[ ! -s "$tmpfile" ]]; then
            msg "Empty annotation, nothing saved."
            return
        fi
        annot="$(cat "$tmpfile")"
    fi

    if task "$id" annotate "$annot"; then
        msg "Annotation added to task $id"
    else
        echo ""
        msg "Error saving annotation."
        if [[ -n "${tmpfile:-}" && -f "${tmpfile:-}" ]]; then
            msg "Your text:"
            echo "---"
            cat "$tmpfile"
            echo "---"
        fi
    fi
}

# ============================================================================
# Edit existing annotation — with optional pre-populated text appended
# ============================================================================

edit_annotation() {
    local id="$1"
    local index="$2"
    local inline_text="${3:-}"   # optional text to append before editing

    local count
    count=$(get_annotation_count "$id")

    if [[ "$count" -eq 0 ]]; then
        die "No annotations on task $id"
    fi

    if [[ "$index" -lt 1 || "$index" -gt "$count" ]]; then
        die "Annotation .$index out of range (task has $count annotation(s))"
    fi

    local old_text
    old_text=$(task _get "$id.annotations.${index}.description" 2>/dev/null)

    if [[ -z "$old_text" ]]; then
        die "Could not read annotation .$index"
    fi

    show_task_context "$id"
    make_tmpfile "$id"

    # Write existing annotation text
    echo "$old_text" > "$tmpfile"

    # Append inline text on a new line if supplied
    if [[ -n "$inline_text" ]]; then
        echo "" >> "$tmpfile"
        echo "$inline_text" >> "$tmpfile"
    fi

    $EDITOR "$tmpfile"

    local new_text
    new_text=$(cat "$tmpfile")

    if [[ "$new_text" == "$old_text" ]]; then
        msg "No changes made."
        return
    fi

    if [[ -z "$new_text" ]]; then
        msg "Annotation emptied — removing it."
        task "$id" denotate "$old_text"
        return
    fi

    if task "$id" denotate "$old_text" 2>/dev/null; then
        if task "$id" annotate "$new_text"; then
            msg "Annotation .$index updated on task $id"
        else
            echo ""
            msg "Error saving new annotation. Old was removed. Your text:"
            echo "---"
            cat "$tmpfile"
            echo "---"
        fi
    else
        msg "Warning: could not remove old annotation. No changes made."
    fi
}

# ============================================================================
# Remove annotation (with confirmation) — index required
# ============================================================================

remove_annotation() {
    local id="$1"
    local index="$2"

    local count
    count=$(get_annotation_count "$id")

    if [[ "$count" -eq 0 ]]; then
        die "No annotations on task $id"
    fi

    if [[ "$index" -lt 1 || "$index" -gt "$count" ]]; then
        die "Annotation .$index out of range (task has $count annotation(s))"
    fi

    local ann_text
    ann_text=$(task _get "$id.annotations.${index}.description" 2>/dev/null)

    if [[ -z "$ann_text" ]]; then
        die "Could not read annotation .$index"
    fi

    local desc
    desc=$(task _get "$id.description" 2>/dev/null)
    echo "Task $id: $desc"
    echo "---"

    local ann_entry
    ann_entry=$(task _get "$id.annotations.${index}.entry" 2>/dev/null)
    local date_str="$ann_entry"
    if command -v date &>/dev/null && [[ -n "$ann_entry" ]]; then
        date_str=$(date -d "$ann_entry" "+%Y-%m-%d %H:%M" 2>/dev/null) || date_str="$ann_entry"
    fi

    printf "  .%-3d [%s]\n" "$index" "$date_str"
    echo "$ann_text" | sed 's/^/       /'
    echo ""

    read -rp "Remove this annotation? [y/N]: " response
    if [[ "${response,,}" != "y" ]]; then
        msg "Cancelled."
        return
    fi

    if task "$id" denotate "$ann_text"; then
        msg "Annotation .$index removed from task $id"
    else
        msg "Error: could not remove annotation .$index"
    fi
}

# ============================================================================
# Main
# ============================================================================

# Handle flags (only when stdin is a terminal — pipes shouldn't trigger usage)
if [[ -t 0 ]]; then
    case "${1:-}" in
        -h|--help) usage ;;
        -v|--version) echo "annn v$VERSION"; exit 0 ;;
        "") usage ;;
    esac
else
    if [[ $# -eq 0 ]]; then
        die "Usage: echo \"text\" | $SCRIPT_NAME <id>"
    fi
fi

# ============================================================================
# Argument parsing
#
# Strict: arg1 must be integer, integer+dot, integer+dot+N, -integer.N, or UUID.
# No filter expressions, project:, +tag, or bare words permitted as ID.
#
# Accepted forms:
#   annn 42               → new annotation (editor)
#   annn 42 text...       → new annotation (inline, no editor)
#   annn 42.              → list annotations
#   annn 42.3             → edit annotation 3 (editor)
#   annn 42.3 text...     → edit annotation 3 (editor, text appended)
#   annn -42.3            → remove annotation 3
# ============================================================================

arg1="${1:-}"
shift

# Validate arg1 before anything else
validate_id_arg "$arg1"

remove_mode=false
filter=""
action="new"
ann_index=""

if [[ "$arg1" =~ ^-([0-9]+)\.([0-9]+)$ ]]; then
    # Remove mode: -42.3
    filter="${BASH_REMATCH[1]}"
    ann_index="${BASH_REMATCH[2]}"
    remove_mode=true

elif [[ "$arg1" =~ ^-([0-9]+)(\.?)$ ]]; then
    # -42 or -42. without an index — ambiguous, require index
    die "Remove requires an annotation index: use -${BASH_REMATCH[1]}.<N>"

elif [[ "$arg1" =~ ^([0-9]+)\.([0-9]+)$ ]]; then
    # Combined edit: 42.3
    filter="${BASH_REMATCH[1]}"
    ann_index="${BASH_REMATCH[2]}"
    action="edit"

elif [[ "$arg1" =~ ^([0-9]+)\.$  ]]; then
    # List: 42.
    filter="${BASH_REMATCH[1]}"
    action="list"

elif is_integer "$arg1" || is_uuid "$arg1"; then
    # Plain ID — new annotation (or inline if args follow)
    filter="$arg1"
    action="new"

else
    die "Invalid ID: '$arg1' — must be a plain integer or UUID"
fi

# Resolve to confirmed task ID
id=$(resolve_id "$filter")

# Collect any remaining args as inline text
inline_text=""
if [[ $# -gt 0 ]]; then
    inline_text="$*"
fi

# ============================================================================
# Dispatch
# ============================================================================

if [[ "$remove_mode" == true ]]; then
    if ! [[ "$ann_index" =~ ^[0-9]+$ ]]; then
        die "Invalid annotation index: .$ann_index"
    fi
    remove_annotation "$id" "$ann_index"

else
    case "$action" in
        list)
            list_annotations "$id"
            ;;
        edit)
            if ! [[ "$ann_index" =~ ^[0-9]+$ ]]; then
                die "Invalid annotation index: .$ann_index"
            fi
            edit_annotation "$id" "$ann_index" "$inline_text"
            ;;
        new)
            new_annotation "$id" "$inline_text"
            ;;
        *)
            die "Unknown action: $action"
            ;;
    esac
fi
